// NormalIntDistribution.h
//
// ICS 65 Fall 2012
// Code Example
//
// This is an implementation of a custom random number distribution, according
// to the same model followed by the random number distributions built into
// the C++ standard library.  The important behavior that these distributions
// must provide are:
//
// (1) A reset() function that resets their state.  In the case of this
//     distribution, there's no state to reset, so our reset() function is
//     empty.
//
// (2) An separate overloaded function call operator -- operator() -- for
//     each possible kind of random number engine you might like to use with
//     this distribution.
//
// There is a small handful of other stuff that might also be required, but
// this is a very good start and will work for our use here.
//
// In order to make our NormalIntDistribution more flexible, templates are
// used in a couple of places:
//
// * The NormalIntDistribution class is a template class, with one type
//   parameter that specifies the kinds of values it will generate.  So,
//   for example, NormalIntDistribution<unsigned int> would generate
//   unsigned ints as its results.  Every time we create a
//   NormalIntDistribution object with a new result type, the compiler
//   will use the template class to generate us a fresh new class.
//
// * The overloaded function call operator is what's called a "template
//   member function" (which we may not see again in this course, but
//   turns out to be vital here), which allows you to specify a blueprint
//   for a potentially infinite set of member functions; in this case,
//   we want a separate function call operator for each possible random
//   number engine we might like to plug into our distribution.  Whenever
//   we plug a new kind of engine into our distribution and use the
//   function call operator on it, the compiler will generate a new member
//   function for us automatically.
//
// As we'll see in subsequent code examples, templates need to be defined
// in header files, because they specify a blueprint that the compiler will
// need to have available whenever, in any source file, any part of the
// template gets used, so that new classes (and, in our case, new function
// call operators) can be generated by the compiler as needed.

#ifndef NORMALINTDISTRIBUTION_H
#define NORMALINTDISTRIBUTION_H

#include <random>
#include <limits>
#include <cmath>



template <typename IntType>
class NormalIntDistribution
{
public:
        // Our constructor will take up to four parameters:
        //
        // * "mean", specifying the average value we expect to get back from
        //   our distribution
        // * "stdev", specifying the standard deviation of the values we expect
        //   to get back from our distribution
        // * "min", which is the minimum value we want to get back from our
        //   distribution, with the default being the minimum value for our
        //   chosen result type
        // * "max", which is the maximum value we want to get back from our
        //   distribution, with the default being the maximum value for our
        //   chosen result type
        NormalIntDistribution(
                double mean, double stdev,
                IntType min = std::numeric_limits<IntType>::min(),
                IntType max = std::numeric_limits<IntType>::max());


        // reset() resets the internal state of our distribution.  We have
        // no meaningful internal state, so this function, in our distribution,
        // does nothing.
        void reset();


        // Notice that we've declared this member function to be a template
        // itself.  That means classes generated from this template class can
        // have any number of these function call operators, which will be
        // generated, from this template implementation, on the fly as needed.
        //
        // Note, too, that overloading "operator()" is a way to make an object
        // be able to act like a function, with the parameters to "operator()"
        // being the parameters you can pass to that function.  So, in our
        // case, given a NormalIntDistribution<unsigned int> object, we'd be
        // able to call it like a function by passing it a random number
        // engine:
        //
        //     std::mt19937 engine;
        //     NormalIntDistribution<unsigned int> d(50, 10, 1, 100);
        //     unsigned int value = d(engine);

        template <typename EngineType>
        IntType operator()(EngineType& engine);

private:
        std::normal_distribution<double> normal;
        IntType min;
        IntType max;
};



template <typename IntType>
NormalIntDistribution<IntType>::NormalIntDistribution(double mean, double stdev, IntType min, IntType max)
        : normal(mean, stdev), min(min), max(max)
{
}


template <typename IntType>
void NormalIntDistribution<IntType>::reset()
{
}


// This rather strange-looking syntax is necessary because we're implementing
// a template member function declared inside of a template class.  So we need
// to tell the compiler how to generate these functions, which are actually
// instantiations of two different templates (one inside another).
template <typename IntType>
template <typename EngineType>
IntType NormalIntDistribution<IntType>::operator()(EngineType& engine)
{
        while (true)
        {
                double value = normal(engine);

                if (value < min)
                {
                        return static_cast<IntType>(min); //modified from the original
                }
                else if (value > max)
                {
                        return static_cast<IntType>(max); //modified from the original
                }
                else
                {
                        return static_cast<IntType>(value);
                }
        }
}



// As I mentioned in lecture, there are some fairly gnarly bits here.  If
// you've read through the comments here and aren't sure what you're looking
// at, don't feel bad; this is a combination of a few relatively advanced C++
// topics, not all of which we've covered so far.  But the usefulness of this
// building block for your Project #4 implementation made me decide to provide
// this implementation and, for those of you who are interested in seeing
// behind the curtain, show you how it works.
//
// C++ is complicated, but it is enormously flexible.  This header file is a
// microcosm of some of that flexibility -- which, by the way, will mostly
// be resolved at compile time and have virtually no run-time cost, except
// to the extent to which we ask the compiler to generate large numbers of
// different implementations from our templates.  But in a given program,
// there are likely to be only a small handful (or maybe only one) of these
// implementations.



#endif // NORMALINTDISTRIBUTION_H
